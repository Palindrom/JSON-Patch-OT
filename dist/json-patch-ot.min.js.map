{"version":3,"sources":["../src/json-patch-ot.js"],"names":["JSONPatchOT","replacePathIfHigher","path","repl","index","result","substr","length","eoindex","indexOf","oldIndex","rest","isValidIndex","str","n","Number","String","transform","sequenceA","sequences","concatAllSequences","concat","apply","clonedPatch","JSON","parse","stringify","reduce","composeJSONPatches","transformAgainstSingleOp","operationObj","original","undefined","value","op","Error","from","transformAgainst","orgOpsLen","currentOp","originalOp","remove","patchOp","splice","lastSlash","lastIndexOf","arrayPath","replace","module","exports","default","__esModule"],"mappings":"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","file":"json-patch-ot.min.js","sourcesContent":["/*!\r\n * https://github.com/Palindrom/JSONPatchOT\r\n * JSON-Patch-OT version: 1.0.1\r\n * (c) 2017 Tomek Wytrebowicz\r\n * MIT license\r\n */\r\n\r\nvar JSONPatchOT = (function(){\r\n\r\n  var debug = false;\r\n  var JSONPatchOT = JSONPatchOT || {};\r\n  JSONPatchOT.transform = function (sequenceA, sequences) {\r\n    var concatAllSequences = [];\r\n    concatAllSequences = concatAllSequences.concat.apply(concatAllSequences, sequences);\r\n    // var clonedPatch = JSON.parse(JSON.stringify(this.patch)); // clone needed for debugging and visualization\r\n    var clonedPatch = JSON.parse(JSON.stringify(sequenceA)); // clone needed for debugging and visualization\r\n    var result = concatAllSequences.reduce(composeJSONPatches, clonedPatch); // <=> composeJSONPatches(this, operations.concat() )\r\n    return result;\r\n    // return new JSONPatchOperation(result, this.localRevision, operations[operations.length-1].localRevision, this.localRevPropName, this.remoteRevPropName);\r\n  };\r\n  JSONPatchOT.transformAgainstSingleOp = function(sequenceA, operationObj){\r\n\r\n  };\r\n  var composeJSONPatches = function( original, operationObj ){\r\n\r\n      // basic validation (as in fast-json-patch)\r\n      if (operationObj.value === undefined && (operationObj.op === \"add\" || operationObj.op === \"replace\" || operationObj.op === \"test\")) {\r\n          throw new Error(\"'value' MUST be defined\");\r\n      }\r\n      if (operationObj.from === undefined && (operationObj.op === \"copy\" || operationObj.op === \"move\")) {\r\n          throw new Error(\"'from' MUST be defined\");\r\n      }\r\n\r\n      // apply patch operation to all original ops\r\n      if(transformAgainst[operationObj.op]){ // if we have any function to transform operationObj.op at all\r\n        if(typeof transformAgainst[operationObj.op] == \"function\"){ //not perfectly performant but gives easier maintenance and flexibility with transformations\r\n          transformAgainst[operationObj.op](operationObj, original);\r\n        } else {\r\n          var orgOpsLen = original.length, currentOp = 0;\r\n          while (currentOp < orgOpsLen) {\r\n            var originalOp = original[currentOp];\r\n            currentOp++;\r\n\r\n            if( transformAgainst[operationObj.op][originalOp.op] ){\r\n              transformAgainst[operationObj.op][originalOp.op](operationObj, originalOp)\r\n            } else{\r\n              debug && console.log(\"No function to transform \" + originalOp.op + \"against\" + operationObj.op);\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        debug && console.log(\"No function to transform against \" + operationObj.op)\r\n      }\r\n      return original;\r\n    };\r\n    var transformAgainst = {\r\n      remove: function(patchOp, original){\r\n        debug && console.log(\"Transforming \", JSON.stringify(original) ,\" against `remove` \", patchOp);\r\n        var orgOpsLen = original.length, currentOp = 0, originalOp;\r\n        // remove operation objects\r\n        while (originalOp = original[currentOp]) {\r\n\r\n\r\n          // TODO: `move`, and `copy` (`from`) may not be covered well (tomalec)\r\n          debug && console.log(\"TODO: `move`, and `copy` (`from`) may not be covered well (tomalec)\");\r\n          if( (originalOp.op === 'add' || originalOp.op === 'test') && patchOp.path === originalOp.path ){\r\n            // do nothing ? (tomalec)\r\n          } else\r\n          // node in question was removed\r\n          if( originalOp.from &&\r\n                  (originalOp.from === patchOp.path || originalOp.from.indexOf(patchOp.path + \"/\") === 0 ) ||\r\n              ( patchOp.path === originalOp.path || originalOp.path.indexOf(patchOp.path + \"/\") === 0 ) ){\r\n            debug && console.log(\"Removing \", originalOp);\r\n            original.splice(currentOp,1);\r\n            orgOpsLen--;\r\n            currentOp--;\r\n          }\r\n          currentOp++;\r\n        }\r\n        // shift indexes\r\n        // var match = patchOp.path.match(/(.*\\/)(\\d+)$/); // last element is a number\r\n        var lastSlash = patchOp.path.lastIndexOf(\"/\");\r\n        if( lastSlash > -1){\r\n          var index = patchOp.path.substr(lastSlash+1);\r\n          var arrayPath = patchOp.path.substr(0,lastSlash+1);\r\n          if( isValidIndex(index)){\r\n            debug && console.warn(\"Bug prone guessing that, as number given in path, this is an array!\");\r\n\r\n            debug && console.log(\"Shifting array indexes\");\r\n            orgOpsLen = original.length;\r\n            currentOp = 0;\r\n            while (currentOp < orgOpsLen) {\r\n              originalOp = original[currentOp];\r\n              currentOp++;\r\n\r\n              if(originalOp.path.indexOf(arrayPath) === 0){//item from the same array\r\n                originalOp.path = replacePathIfHigher(originalOp.path, arrayPath, index);\r\n              }\r\n              if(originalOp.from && originalOp.from.indexOf(arrayPath) === 0){//item from the same array\r\n                originalOp.from = replacePathIfHigher(originalOp.from, arrayPath, index);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n      },\r\n      replace: function(patchOp, original){\r\n        debug && console.log(\"Transforming \", JSON.stringify(original) ,\" against `replace` \", patchOp);\r\n        var currentOp = 0, originalOp;\r\n        // remove operation objects withing replaced JSON node\r\n        while (originalOp = original[currentOp]) {\r\n\r\n\r\n          // TODO: `move`, and `copy` (`from`) may not be covered well (tomalec)\r\n          debug && console.log(\"TODO: `move`, and `copy` (`from`) may not be covered well (tomalec)\");\r\n          // node in question was removed\r\n          // IT:\r\n          // if( patchOp.path === originalOp.path || originalOp.path.indexOf(patchOp.path + \"/\") === 0 ){\r\n          if( originalOp.from &&\r\n                  (originalOp.from === patchOp.path || originalOp.from.indexOf(patchOp.path + \"/\") === 0 ) ||\r\n              originalOp.path.indexOf(patchOp.path + \"/\") === 0 ){\r\n            debug && console.log(\"Removing \", originalOp);\r\n            original.splice(currentOp,1);\r\n            currentOp--;\r\n          }\r\n          currentOp++;\r\n        }\r\n\r\n      }\r\n    };\r\n    function replacePathIfHigher(path, repl, index){\r\n      var result = path.substr(repl.length);\r\n      // var match = result.match(/^(\\d+)(.*)/);\r\n      // if(match && match[1] > index){\r\n      var eoindex = result.indexOf(\"/\");\r\n      eoindex > -1 || (eoindex = result.length);\r\n      var oldIndex = result.substr(0, eoindex);\r\n      var rest  = result.substr(eoindex);\r\n      if(isValidIndex(oldIndex) && oldIndex > index){\r\n        return repl + (oldIndex -1) + rest;\r\n      } else {\r\n        return path;\r\n      }\r\n    }\r\n    function isValidIndex(str) {\r\n        var n = ~~Number(str);\r\n        return String(n) === str && n >= 0;\r\n    }\r\n    return JSONPatchOT;\r\n}());\r\n\r\nif(typeof module !== 'undefined') {\r\n  module.exports = JSONPatchOT;\r\n  module.exports.default = JSONPatchOT;\r\n  module.exports.__esModule = true;\r\n}"]}